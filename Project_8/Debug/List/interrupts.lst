###############################################################################
#
# IAR C/C++ Compiler V7.12.1.987/W32 for MSP430           30/Nov/2018  13:38:49
# Copyright 1996-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 7.12
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Andrew\Desktop\“ECE-306_CodeProject_01
#        directory\Project_8\interrupts.c
#    Command line  =  
#        -f C:\Users\Andrew\AppData\Local\Temp\EW38CF.tmp
#        ("C:\Users\Andrew\Desktop\“ECE-306_CodeProject_01
#        directory\Project_8\interrupts.c" -lC
#        "C:\Users\Andrew\Desktop\“ECE-306_CodeProject_01
#        directory\Project_8\Debug\List" -o
#        "C:\Users\Andrew\Desktop\“ECE-306_CodeProject_01
#        directory\Project_8\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --debug -D__MSP430FR5994__ -e --double=32
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\430\lib\dlib\dl430xlsfn.h" --core=430X --data_model=small -On
#        --multiplier=32 --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\Andrew\Desktop\“ECE-306_CodeProject_01
#        directory\Project_8\Debug\List\interrupts.lst
#    Object file   =  
#        C:\Users\Andrew\Desktop\“ECE-306_CodeProject_01
#        directory\Project_8\Debug\Obj\interrupts.r43
#
###############################################################################

C:\Users\Andrew\Desktop\“ECE-306_CodeProject_01 directory\Project_8\interrupts.c
      1          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x818
   \   union <unnamed> _A_ADC12IV_L
   \                     _A_ADC12IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x860
   \   union <unnamed> _A_ADC12MEM0_L
   \                     _A_ADC12MEM0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x862
   \   union <unnamed> _A_ADC12MEM1_L
   \                     _A_ADC12MEM1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x864
   \   union <unnamed> _A_ADC12MEM2_L
   \                     _A_ADC12MEM2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x25a
   \   union <unnamed> _A_PCIE_L
   \                     _A_PCIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x25c
   \   union <unnamed> _A_PCIFG_L
   \                     _A_PCIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x340
   \   union <unnamed> _A_TA0CTL_L
   \                     _A_TA0CTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x342
   \   union <unnamed> _A_TA0CCTL0_L
   \                     _A_TA0CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x344
   \   union <unnamed> _A_TA0CCTL1_L
   \                     _A_TA0CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x352
   \   union <unnamed> _A_TA0CCR0_L
   \                     _A_TA0CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x354
   \   union <unnamed> _A_TA0CCR1_L
   \                     _A_TA0CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x360
   \   union <unnamed> _A_TA0EX0_L
   \                     _A_TA0EX0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x36e
   \   union <unnamed> _A_TA0IV_L
   \                     _A_TA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5cc
   \   union <unnamed> _A_UCA0RXBUF_L
   \                     _A_UCA0RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ce
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5da
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5de
   \   union <unnamed> _A_UCA0IV_L
   \                     _A_UCA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x62c
   \   union <unnamed> _A_UCA3RXBUF_L
   \                     _A_UCA3RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x62e
   \   union <unnamed> _A_UCA3TXBUF_L
   \                     _A_UCA3TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x63a
   \   union <unnamed> _A_UCA3IE_L
   \                     _A_UCA3IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x63e
   \   union <unnamed> _A_UCA3IV_L
   \                     _A_UCA3IV_L:
   \   000000                DS8 2
      2          #include  "functions.h"
      3          #include <string.h>
      4          #include "macros.h"
      5          
      6          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      7          unsigned int  displaybutton2;
   \                     displaybutton2:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      8          unsigned int  displaybutton1;
   \                     displaybutton1:
   \   000000                DS8 2
      9          extern char rstate;
     10          extern volatile unsigned char display_changed;
     11          extern volatile unsigned char update_display;
     12          extern volatile unsigned int update_display_count;
     13          extern volatile unsigned int Time_Sequence;
     14          extern char BaudBool;
     15          
     16          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          volatile unsigned int ADC_Thumb;
   \                     ADC_Thumb:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile unsigned int ADC_Right_Detector;
   \                     ADC_Right_Detector:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile unsigned int ADC_Left_Detector;
   \                     ADC_Left_Detector:
   \   000000                DS8 2
     20          extern volatile unsigned int UCA3_index;
     21          extern volatile unsigned int UCA0_index;
     22          extern char test_command[];
     23          extern volatile char USBCommand[];
     24          
     25          extern volatile unsigned int TA0CCR0counter;
     26          extern volatile unsigned int TA0CCR1counter;
     27          extern volatile unsigned int TA1CCR0counter;
     28          extern volatile unsigned int TA1CCR1counter;
     29          extern volatile unsigned int Button1DebounceCount;
     30          extern volatile unsigned int Button2DebounceCount;
     31          extern volatile unsigned char Button1Debounce;
     32          extern volatile unsigned char Button2Debounce;
     33          extern volatile unsigned char switch_LCD;
     34          extern volatile unsigned int Last_Time_Sequence;
     35          extern volatile unsigned char Button1Pressed;
     36          extern volatile unsigned char Button2Pressed;
     37          
     38          
     39          #pragma vector=PORT5_VECTOR

   \                                 In  segment ISR_CODE, align 2
     40          __interrupt void BUTTON_interrupt(void)
   \                     BUTTON_interrupt:
     41          {
   \   000000   0E12         PUSH.W  R14
     42            //Button 1
     43            if((P5IFG & BUTTON1))
   \   000002   F2B040005C02 BIT.B   #0x40, &0x25c
   \   000008   1D28         JNC     ??BUTTON_interrupt_1
     44            { 
     45              rstate = 2;
   \   00000A   E243....     MOV.B   #0x2, &rstate
     46              Button1Pressed = TRUE;
   \   00000E   D243....     MOV.B   #0x1, &Button1Pressed
     47              Button1Debounce = TRUE;
   \   000012   D243....     MOV.B   #0x1, &Button1Debounce
     48              TA0CCTL1 ON CCIE;
   \   000016   B2D010004403 BIS.W   #0x10, &0x344
     49              TA0CTL OFF TAIFG;
   \   00001C   92C34003     BIC.W   #0x1, &0x340
     50              switch(BaudBool){
   \   000020   5E42....     MOV.B   &BaudBool, R14
   \   000024   4E83         SUB.B   #0x0, R14
   \   000026   0324         JEQ     ??BUTTON_interrupt_2
   \   000028   5E83         SUB.B   #0x1, R14
   \   00002A   0424         JEQ     ??BUTTON_interrupt_3
   \   00002C   053C         JMP     ??BUTTON_interrupt_0
     51            case 0:
     52              BaudBool = 1;
   \                     ??BUTTON_interrupt_2:
   \   00002E   D243....     MOV.B   #0x1, &BaudBool
     53              break;
   \   000032   023C         JMP     ??BUTTON_interrupt_0
     54            case 1:
     55              BaudBool = 0;
   \                     ??BUTTON_interrupt_3:
   \   000034   C243....     MOV.B   #0x0, &BaudBool
     56              break;
     57              }
     58              //BaudBool = !BaudBool;
     59              
     60              P5IFG OFF BUTTON1;
   \                     ??BUTTON_interrupt_0:
   \   000038   F2C040005C02 BIC.B   #0x40, &0x25c
     61              P5IE OFF BUTTON1;
   \   00003E   F2C040005A02 BIC.B   #0x40, &0x25a
     62             
     63              
     64            }
     65            if((P5IFG & BUTTON2))
   \                     ??BUTTON_interrupt_1:
   \   000044   F2B020005C02 BIT.B   #0x20, &0x25c
   \   00004A   1128         JNC     ??BUTTON_interrupt_4
     66            {
     67              Button2Pressed = TRUE;
   \   00004C   D243....     MOV.B   #0x1, &Button2Pressed
     68              Button2Debounce = TRUE;
   \   000050   D243....     MOV.B   #0x1, &Button2Debounce
     69              
     70              rstate = 1;
   \   000054   D243....     MOV.B   #0x1, &rstate
     71             // TA0CCTL0 ON CCIE;
     72              TA0CCTL1 ON CCIE;
   \   000058   B2D010004403 BIS.W   #0x10, &0x344
     73              TA0CTL OFF TAIFG;
   \   00005E   92C34003     BIC.W   #0x1, &0x340
     74              //P5OUT ON LCD_BACKLITE;
     75              
     76              P5IFG OFF BUTTON2;        // Clear all P5.5 interrupt flags
   \   000062   F2C020005C02 BIC.B   #0x20, &0x25c
     77              P5IE OFF BUTTON2;          // P5.6 interrupt enable
   \   000068   F2C020005A02 BIC.B   #0x20, &0x25a
     78            }
     79            
     80          }
   \                     ??BUTTON_interrupt_4:
   \   00006E   3E41         POP.W   R14
   \   000070   0013         RETI
   \   000072                REQUIRE _A_PCIFG_L
   \   000072                REQUIRE _A_TA0CCTL1_L
   \   000072                REQUIRE _A_TA0CTL_L
   \   000072                REQUIRE _A_PCIE_L
     81          
     82          
     83          #pragma vector=TIMER0_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
     84          __interrupt void Timer0_A1_Interrupt(void)
   \                     Timer0_A1_Interrupt:
     85          {
   \   000000   0F12         PUSH.W  R15
     86            
     87          
     88            
     89            switch(__even_in_range(TA0IV,OVERFLOW))
   \   000002   1F426E03     MOV.W   &0x36e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for Timer0_A1_Interrupt>_0`:
   \   000008   303C         JMP     ??Timer0_A1_Interrupt_1
   \   00000A   063C         JMP     ??Timer0_A1_Interrupt_4
   \   00000C   2E3C         JMP     ??Timer0_A1_Interrupt_1
   \   00000E   2D3C         JMP     ??Timer0_A1_Interrupt_1
   \   000010   2C3C         JMP     ??Timer0_A1_Interrupt_1
   \   000012   2B3C         JMP     ??Timer0_A1_Interrupt_1
   \   000014   2A3C         JMP     ??Timer0_A1_Interrupt_1
   \   000016   293C         JMP     ??Timer0_A1_Interrupt_1
     90            {
     91              
     92              case NOINTERRUPT: break; //no interrupt
     93              case CHECKDEBOUNCE: 
     94                
     95                  if(Button1Debounce == TRUE)
   \                     ??Timer0_A1_Interrupt_4:
   \   000018   D293....     CMP.B   #0x1, &Button1Debounce
   \   00001C   1020         JNE     ??Timer0_A1_Interrupt_2
     96                  {
     97                    Button1DebounceCount++;
   \   00001E   9253....     ADD.W   #0x1, &Button1DebounceCount
     98                    if(Button1DebounceCount == DEBOUNCEPERIOD)
   \   000022   B2900500.... CMP.W   #0x5, &Button1DebounceCount
   \   000028   0A20         JNE     ??Timer0_A1_Interrupt_2
     99                    {
    100                      P5IFG OFF BUTTON1;
   \   00002A   F2C040005C02 BIC.B   #0x40, &0x25c
    101                      P5IE ON BUTTON1;
   \   000030   F2D040005A02 BIS.B   #0x40, &0x25a
    102                      Button1Debounce = FALSE;  
   \   000036   C243....     MOV.B   #0x0, &Button1Debounce
    103                      Button1DebounceCount = FALSE;
   \   00003A   8243....     MOV.W   #0x0, &Button1DebounceCount
    104                    }
    105                    
    106                  }
    107                  
    108                  if(Button2Debounce == TRUE)
   \                     ??Timer0_A1_Interrupt_2:
   \   00003E   D293....     CMP.B   #0x1, &Button2Debounce
   \   000042   1020         JNE     ??Timer0_A1_Interrupt_3
    109                  {
    110                    Button2DebounceCount++;
   \   000044   9253....     ADD.W   #0x1, &Button2DebounceCount
    111                    if(Button2DebounceCount >= DEBOUNCEPERIOD)
   \   000048   B2900500.... CMP.W   #0x5, &Button2DebounceCount
   \   00004E   0A28         JNC     ??Timer0_A1_Interrupt_3
    112                    {
    113                      P5IFG OFF BUTTON2;
   \   000050   F2C020005C02 BIC.B   #0x20, &0x25c
    114                      P5IE ON BUTTON2;
   \   000056   F2D020005A02 BIS.B   #0x20, &0x25a
    115                      Button2Debounce = FALSE;
   \   00005C   C243....     MOV.B   #0x0, &Button2Debounce
    116                      Button2DebounceCount = FALSE;
   \   000060   8243....     MOV.W   #0x0, &Button2DebounceCount
    117                    }
    118                  }
    119                  TA0CCR1 += TA0CCR1_INTERVAL;
   \                     ??Timer0_A1_Interrupt_3:
   \   000064   B250A8615403 ADD.W   #0x61a8, &0x354
    120                  break;
    121            case  TA0CCR1ADD:
    122              
    123              break;
    124            case OVERFLOW:
    125              break;
    126            default: break;
    127            }
    128          }
   \                     ??Timer0_A1_Interrupt_1:
   \   00006A   3F41         POP.W   R15
   \   00006C   0013         RETI
   \   00006E                REQUIRE _A_PCIFG_L
   \   00006E                REQUIRE _A_PCIE_L
   \   00006E                REQUIRE _A_TA0CCR1_L
   \   00006E                REQUIRE _A_TA0IV_L
    129          
    130          
    131          #pragma vector = TIMER0_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    132          __interrupt void Timer0_A0_ISR(void) {
   \                     Timer0_A0_ISR:
   \   000000   3F15         PUSHM.W #0x4, R15
    133            TA0CCR0 += TA0CCR0_INTERVAL;
   \   000002   B250A8615203 ADD.W   #0x61a8, &0x352
    134            TA0CCR0counter++;
   \   000008   9253....     ADD.W   #0x1, &TA0CCR0counter
    135              
    136                update_display = TRUE;
   \   00000C   D243....     MOV.B   #0x1, &update_display
    137                //display_changed = TRUE;
    138                
    139                Display_Update(FALSE,FALSE,FALSE,FALSE);
   \   000010   4F43         MOV.B   #0x0, R15
   \   000012   4E43         MOV.B   #0x0, R14
   \   000014   4D43         MOV.B   #0x0, R13
   \   000016   4C43         MOV.B   #0x0, R12
   \   000018   ........     CALLA   #Display_Update
    140            
    141          
    142              if( switch_LCD == FALSE)
   \   00001C   C293....     CMP.B   #0x0, &switch_LCD
   \   000020   0520         JNE     ??Timer0_A0_ISR_1
    143              {
    144                switch_LCD = TRUE;
   \   000022   D243....     MOV.B   #0x1, &switch_LCD
    145                P1OUT ON GRN_LED;
   \   000026   E2D30202     BIS.B   #0x2, &0x202
   \   00002A   073C         JMP     ??Timer0_A0_ISR_0
    146              }
    147              else if( switch_LCD)
   \                     ??Timer0_A0_ISR_1:
   \   00002C   C293....     CMP.B   #0x0, &switch_LCD
   \   000030   0424         JEQ     ??Timer0_A0_ISR_0
    148              {
    149                P1OUT OFF GRN_LED;
   \   000032   E2C30202     BIC.B   #0x2, &0x202
    150                switch_LCD = FALSE;
   \   000036   C243....     MOV.B   #0x0, &switch_LCD
    151              }
    152          
    153          }
   \                     ??Timer0_A0_ISR_0:
   \   00003A   3C17         POPM.W  #0x4, R15
   \   00003C   0013         RETI
   \   00003E                REQUIRE _A_TA0CCR0_L
   \   00003E                REQUIRE _A_PAOUT_L
    154          

   \                                 In  segment CODE, align 2
    155          void Init_Timer_A0(void)
   \                     Init_Timer_A0:
    156          {
    157             
    158            TA0CTL = TASSEL__SMCLK;
   \   000000   B24000024003 MOV.W   #0x200, &0x340
    159            TA0CTL ON TACLR;
   \   000006   A2D24003     BIS.W   #0x4, &0x340
    160            TA0CTL ON MC__CONTINUOUS;
   \   00000A   B2D020004003 BIS.W   #0x20, &0x340
    161            TA0CTL ON ID__8;
   \   000010   B2D0C0004003 BIS.W   #0xc0, &0x340
    162           
    163            TA0EX0 = TAIDEX_7;
   \   000016   B24007006003 MOV.W   #0x7, &0x360
    164           
    165            TA0CCR0 = TA0CCR0_INTERVAL;
   \   00001C   B240A8615203 MOV.W   #0x61a8, &0x352
    166            TA0CCTL0 ON CCIE;
   \   000022   B2D010004203 BIS.W   #0x10, &0x342
    167            
    168            TA0CCR1 = TA0CCR1_INTERVAL;
   \   000028   B240A8615403 MOV.W   #0x61a8, &0x354
    169            TA0CCTL1 OFF CCIE;
   \   00002E   B2C010004403 BIC.W   #0x10, &0x344
    170            
    171            TA0CTL OFF TAIE;
   \   000034   A2C34003     BIC.W   #0x2, &0x340
    172            TA0CTL OFF TAIFG;
   \   000038   92C34003     BIC.W   #0x1, &0x340
    173          }
   \   00003C   1001         RETA
   \   00003E                REQUIRE _A_TA0CTL_L
   \   00003E                REQUIRE _A_TA0EX0_L
   \   00003E                REQUIRE _A_TA0CCR0_L
   \   00003E                REQUIRE _A_TA0CCTL0_L
   \   00003E                REQUIRE _A_TA0CCR1_L
   \   00003E                REQUIRE _A_TA0CCTL1_L
    174          
    175          #pragma vector = ADC12_B_VECTOR

   \                                 In  segment ISR_CODE, align 2
    176          __interrupt void ADC12_ISR(void){
   \                     ADC12_ISR:
   \   000000   0F12         PUSH.W  R15
    177          switch(__even_in_range(ADC12IV, ADC12IV__ADC12RDYIFG)){
   \   000002   1F421808     MOV.W   &0x818, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for ADC12_ISR>_0`:
   \   000008   2F3C         JMP     ??ADC12_ISR_1
   \   00000A   2E3C         JMP     ??ADC12_ISR_1
   \   00000C   2D3C         JMP     ??ADC12_ISR_1
   \   00000E   2C3C         JMP     ??ADC12_ISR_1
   \   000010   2B3C         JMP     ??ADC12_ISR_1
   \   000012   2A3C         JMP     ??ADC12_ISR_1
   \   000014   293C         JMP     ??ADC12_ISR_1
   \   000016   283C         JMP     ??ADC12_ISR_1
   \   000018   1E3C         JMP     ??ADC12_ISR_2
   \   00001A   263C         JMP     ??ADC12_ISR_1
   \   00001C   253C         JMP     ??ADC12_ISR_1
   \   00001E   243C         JMP     ??ADC12_ISR_1
   \   000020   233C         JMP     ??ADC12_ISR_1
   \   000022   223C         JMP     ??ADC12_ISR_1
   \   000024   213C         JMP     ??ADC12_ISR_1
   \   000026   203C         JMP     ??ADC12_ISR_1
   \   000028   1F3C         JMP     ??ADC12_ISR_1
   \   00002A   1E3C         JMP     ??ADC12_ISR_1
   \   00002C   1D3C         JMP     ??ADC12_ISR_1
   \   00002E   1C3C         JMP     ??ADC12_ISR_1
   \   000030   1B3C         JMP     ??ADC12_ISR_1
   \   000032   1A3C         JMP     ??ADC12_ISR_1
   \   000034   193C         JMP     ??ADC12_ISR_1
   \   000036   183C         JMP     ??ADC12_ISR_1
   \   000038   173C         JMP     ??ADC12_ISR_1
   \   00003A   163C         JMP     ??ADC12_ISR_1
   \   00003C   153C         JMP     ??ADC12_ISR_1
   \   00003E   143C         JMP     ??ADC12_ISR_1
   \   000040   133C         JMP     ??ADC12_ISR_1
   \   000042   123C         JMP     ??ADC12_ISR_1
   \   000044   113C         JMP     ??ADC12_ISR_1
   \   000046   103C         JMP     ??ADC12_ISR_1
   \   000048   0F3C         JMP     ??ADC12_ISR_1
   \   00004A   0E3C         JMP     ??ADC12_ISR_1
   \   00004C   0D3C         JMP     ??ADC12_ISR_1
   \   00004E   0C3C         JMP     ??ADC12_ISR_1
   \   000050   0B3C         JMP     ??ADC12_ISR_1
   \   000052   0A3C         JMP     ??ADC12_ISR_1
   \   000054   093C         JMP     ??ADC12_ISR_1
    178          case ADC12IV__NONE: break; // Vector 0: No interrupt
    179          case ADC12IV__ADC12OVIFG: break; // Vector 2: ADC12MEMx Overflow
    180          case ADC12IV__ADC12TOVIFG: break; // Vector 4: Conversion time overflow
    181          case ADC12IV__ADC12HIIFG: break; // Vector 6: ADC12BHI
    182          case ADC12IV__ADC12LOIFG: break; // Vector 8: ADC12BLO
    183          case ADC12IV__ADC12INIFG: break; // Vector 10: ADC12BIN
    184          case ADC12IV__ADC12IFG0: break; // Vector 12: ADC12MEM0 Interrupt
    185          case ADC12IV__ADC12IFG1: break; // Vector 14: ADC12MEM1 Interrupt
    186          case ADC12IV__ADC12IFG2: // Vector 16: ADC12MEM2 Interrupt
    187          ADC_Thumb = ADC12MEM0; // A02 ADC10INCH_2
   \                     ??ADC12_ISR_2:
   \   000056   92426008.... MOV.W   &0x860, &ADC_Thumb
    188          ADC_Right_Detector = ADC12MEM1; // A05 ADC10INCH_4
   \   00005C   92426208.... MOV.W   &0x862, &ADC_Right_Detector
    189          ADC_Left_Detector = ADC12MEM2; // A04 ADC10INCH_5
   \   000062   92426408.... MOV.W   &0x864, &ADC_Left_Detector
    190          break;
    191          case ADC12IV__ADC12IFG3: break; // Vector 18: ADC12MEM3
    192          case ADC12IV__ADC12IFG4: break; // Vector 20: ADC12MEM4
    193          case ADC12IV__ADC12IFG5: break; // Vector 22: ADC12MEM5
    194          case ADC12IV__ADC12IFG6: break; // Vector 24: ADC12MEM6
    195          case ADC12IV__ADC12IFG7: break; // Vector 26: ADC12MEM7
    196          case ADC12IV__ADC12IFG8: break; // Vector 28: ADC12MEM8
    197          
    198          case ADC12IV__ADC12IFG9: break; // Vector 30: ADC12MEM9
    199          case ADC12IV__ADC12IFG10: break; // Vector 32: ADC12MEM10
    200          case ADC12IV__ADC12IFG11: break; // Vector 34: ADC12MEM11
    201          case ADC12IV__ADC12IFG12: break; // Vector 36: ADC12MEM12
    202          case ADC12IV__ADC12IFG13: break; // Vector 38: ADC12MEM13
    203          case ADC12IV__ADC12IFG14: break; // Vector 40: ADC12MEM14
    204          case ADC12IV__ADC12IFG15: break; // Vector 42: ADC12MEM15
    205          case ADC12IV__ADC12IFG16: break; // Vector 44: ADC12MEM16
    206          case ADC12IV__ADC12IFG17: break; // Vector 46: ADC12MEM17
    207          case ADC12IV__ADC12IFG18: break; // Vector 48: ADC12MEM18
    208          case ADC12IV__ADC12IFG19: break; // Vector 50: ADC12MEM19
    209          case ADC12IV__ADC12IFG20: break; // Vector 52: ADC12MEM20
    210          case ADC12IV__ADC12IFG21: break; // Vector 54: ADC12MEM21
    211          case ADC12IV__ADC12IFG22: break; // Vector 56: ADC12MEM22
    212          case ADC12IV__ADC12IFG23: break; // Vector 58: ADC12MEM23
    213          case ADC12IV__ADC12IFG24: break; // Vector 60: ADC12MEM24
    214          case ADC12IV__ADC12IFG25: break; // Vector 62: ADC12MEM25
    215          case ADC12IV__ADC12IFG26: break; // Vector 64: ADC12MEM26
    216          case ADC12IV__ADC12IFG27: break; // Vector 66: ADC12MEM27
    217          case ADC12IV__ADC12IFG28: break; // Vector 68: ADC12MEM28
    218          case ADC12IV__ADC12IFG29: break; // Vector 70: ADC12MEM29
    219          case ADC12IV__ADC12IFG30: break; // Vector 72: ADC12MEM30
    220          case ADC12IV__ADC12IFG31: break; // Vector 74: ADC12MEM31
    221          case ADC12IV__ADC12RDYIFG: break; // Vector 76: ADC12RDY
    222          default: break;
    223          }
    224          }
   \                     ??ADC12_ISR_1:
   \   000068   3F41         POP.W   R15
   \   00006A   0013         RETI
   \   00006C                REQUIRE _A_ADC12MEM0_L
   \   00006C                REQUIRE _A_ADC12MEM1_L
   \   00006C                REQUIRE _A_ADC12MEM2_L
   \   00006C                REQUIRE _A_ADC12IV_L
    225          
    226          //------------------------------------------------------------------------------
    227          
    228          // global variables
    229          extern volatile unsigned int usb_rx_ring_wr;
    230          extern volatile char USB_Char_Rx[SMALL_RING_SIZE] ;
    231          //------------------------------------------------------------------------------
    232          #pragma vector=USCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    233          __interrupt void USCI_A0_ISR(void){
   \                     USCI_A0_ISR:
   \   000000   2F15         PUSHM.W #0x3, R15
    234          unsigned int temp;
    235          switch(__even_in_range(UCA0IV,0x08)){
   \   000002   1F42DE05     MOV.W   &0x5de, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for USCI_A0_ISR>_0`:
   \   000008   463C         JMP     ??USCI_A0_ISR_2
   \   00000A   033C         JMP     ??USCI_A0_ISR_7
   \   00000C   133C         JMP     ??USCI_A0_ISR_8
   \   00000E   433C         JMP     ??USCI_A0_ISR_2
   \   000010   423C         JMP     ??USCI_A0_ISR_2
    236          case 0: // Vector 0 - no interrupt
    237          break;
    238          case 2: // Vector 2 - RXIFG
    239          temp = usb_rx_ring_wr;
   \                     ??USCI_A0_ISR_7:
   \   000012   1D42....     MOV.W   &usb_rx_ring_wr, R13
    240          USB_Char_Rx[temp] = UCA0RXBUF; // RX -> USB_Char_Rx character
   \   000016   1E42CC05     MOV.W   &0x5cc, R14
   \   00001A   CD4E....     MOV.B   R14, USB_Char_Rx(R13)
    241          if (++usb_rx_ring_wr >= (SMALL_RING_SIZE)){
   \   00001E   1F42....     MOV.W   &usb_rx_ring_wr, R15
   \   000022   1F53         ADD.W   #0x1, R15
   \   000024   824F....     MOV.W   R15, &usb_rx_ring_wr
   \   000028   3F901000     CMP.W   #0x10, R15
   \   00002C   3428         JNC     ??USCI_A0_ISR_2
    242          usb_rx_ring_wr = BEGINNING; // Circular buffer back to beginning
   \   00002E   8243....     MOV.W   #0x0, &usb_rx_ring_wr
    243          }
    244          break;
   \   000032   313C         JMP     ??USCI_A0_ISR_2
    245          case 4: // Vector 4 – TXIFG
    246            switch(UCA0_index++){
   \                     ??USCI_A0_ISR_8:
   \   000034   1F42....     MOV.W   &UCA0_index, R15
   \   000038   0E4F         MOV.W   R15, R14
   \   00003A   1E53         ADD.W   #0x1, R14
   \   00003C   824E....     MOV.W   R14, &UCA0_index
   \   000040   0F83         SUB.W   #0x0, R15
   \   000042   1724         JEQ     ??USCI_A0_ISR_4
   \   000044   1F83         SUB.W   #0x1, R15
   \   000046   1524         JEQ     ??USCI_A0_ISR_4
   \   000048   1F83         SUB.W   #0x1, R15
   \   00004A   1324         JEQ     ??USCI_A0_ISR_4
   \   00004C   1F83         SUB.W   #0x1, R15
   \   00004E   1124         JEQ     ??USCI_A0_ISR_4
   \   000050   1F83         SUB.W   #0x1, R15
   \   000052   0F24         JEQ     ??USCI_A0_ISR_4
   \   000054   1F83         SUB.W   #0x1, R15
   \   000056   0D24         JEQ     ??USCI_A0_ISR_4
   \   000058   1F83         SUB.W   #0x1, R15
   \   00005A   0B24         JEQ     ??USCI_A0_ISR_4
   \   00005C   1F83         SUB.W   #0x1, R15
   \   00005E   0924         JEQ     ??USCI_A0_ISR_4
   \   000060   1F83         SUB.W   #0x1, R15
   \   000062   0724         JEQ     ??USCI_A0_ISR_4
   \   000064   1F83         SUB.W   #0x1, R15
   \   000066   0524         JEQ     ??USCI_A0_ISR_4
   \   000068   1F83         SUB.W   #0x1, R15
   \   00006A   0B24         JEQ     ??USCI_A0_ISR_5
   \   00006C   1F83         SUB.W   #0x1, R15
   \   00006E   0D24         JEQ     ??USCI_A0_ISR_6
   \   000070   103C         JMP     ??USCI_A0_ISR_3
    247              case 0: //
    248              case 1: //
    249              case 2: //
    250              case 3: //
    251              case 4: //
    252              case 5: //
    253              case 6: //
    254              case 7: //
    255              case 8: //
    256              case 9: //
    257              UCA0TXBUF = test_command[UCA3_index];
   \                     ??USCI_A0_ISR_4:
   \   000072   1F42....     MOV.W   &UCA3_index, R15
   \   000076   5F4F....     MOV.B   test_command(R15), R15
   \   00007A   4F4F         MOV.B   R15, R15
   \   00007C   824FCE05     MOV.W   R15, &0x5ce
    258              break;
   \   000080   0A3C         JMP     ??USCI_A0_ISR_2
    259              case 10: //
    260              UCA0TXBUF = 0x0D;
   \                     ??USCI_A0_ISR_5:
   \   000082   B2400D00CE05 MOV.W   #0xd, &0x5ce
    261              break;
   \   000088   063C         JMP     ??USCI_A0_ISR_2
    262              case 11: // Vector 0 - no interrupt
    263              UCA0TXBUF = 0x0A;
   \                     ??USCI_A0_ISR_6:
   \   00008A   B2400A00CE05 MOV.W   #0xa, &0x5ce
    264              break;
   \   000090   023C         JMP     ??USCI_A0_ISR_2
    265              default:
    266              UCA0IE &= ~UCTXIE; // Disable TX interrupt
   \                     ??USCI_A0_ISR_3:
   \   000092   A2C3DA05     BIC.W   #0x2, &0x5da
    267              break;
    268          }
    269          break;
    270          default: break;
    271          }
    272          }
   \                     ??USCI_A0_ISR_2:
   \   000096   2D17         POPM.W  #0x3, R15
   \   000098   0013         RETI
   \   00009A                REQUIRE _A_UCA0RXBUF_L
   \   00009A                REQUIRE _A_UCA0TXBUF_L
   \   00009A                REQUIRE _A_UCA0IE_L
   \   00009A                REQUIRE _A_UCA0IV_L
    273          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    274           int countChar;
   \                     countChar:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    275          char readFlag = 0;
   \                     readFlag:
   \   000000                DS8 1
    276          
    277          
    278          //------------------------------------------------------------------------------
    279          #pragma vector=USCI_A3_VECTOR

   \                                 In  segment ISR_CODE, align 2
    280          __interrupt void USCI_A3_ISR(void){
   \                     USCI_A3_ISR:
   \   000000   2F15         PUSHM.W #0x3, R15
    281          unsigned int temp;
    282          switch(__even_in_range(UCA3IV,0x08)){
   \   000002   1F423E06     MOV.W   &0x63e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for USCI_A3_ISR>_0`:
   \   000008   613C         JMP     ??USCI_A3_ISR_2
   \   00000A   033C         JMP     ??USCI_A3_ISR_10
   \   00000C   2E3C         JMP     ??USCI_A3_ISR_11
   \   00000E   5E3C         JMP     ??USCI_A3_ISR_2
   \   000010   5D3C         JMP     ??USCI_A3_ISR_2
    283          case 0: // Vector 0 - no interrupt
    284          break;
    285          case 2: // Vector 2 - RXIFG
    286          temp = usb_rx_ring_wr;
   \                     ??USCI_A3_ISR_10:
   \   000012   1D42....     MOV.W   &usb_rx_ring_wr, R13
    287          
    288          
    289          
    290          if(UCA3RXBUF == '$'){
   \   000016   B29024002C06 CMP.W   #0x24, &0x62c
   \   00001C   0220         JNE     ??USCI_A3_ISR_4
    291              
    292              readFlag = 1;
   \   00001E   D243....     MOV.B   #0x1, &readFlag
    293          }
    294           
    295          if(UCA3RXBUF == '\n'){
   \                     ??USCI_A3_ISR_4:
   \   000022   B2900A002C06 CMP.W   #0xa, &0x62c
   \   000028   0620         JNE     ??USCI_A3_ISR_5
    296              rstate = 4;
   \   00002A   E242....     MOV.B   #0x4, &rstate
    297              readFlag = 0;
   \   00002E   C243....     MOV.B   #0x0, &readFlag
    298              countChar = 0;
   \   000032   8243....     MOV.W   #0x0, &countChar
    299          }
    300          
    301          
    302          if(readFlag)
   \                     ??USCI_A3_ISR_5:
   \   000036   C293....     CMP.B   #0x0, &readFlag
   \   00003A   0824         JEQ     ??USCI_A3_ISR_6
    303          {
    304             USBCommand[countChar] = UCA3RXBUF;
   \   00003C   1E422C06     MOV.W   &0x62c, R14
   \   000040   1F42....     MOV.W   &countChar, R15
   \   000044   CF4E....     MOV.B   R14, USBCommand(R15)
    305             countChar++;
   \   000048   9253....     ADD.W   #0x1, &countChar
    306          }
    307          USB_Char_Rx[temp] = UCA3RXBUF; // RX -> USB_Char_Rx character
   \                     ??USCI_A3_ISR_6:
   \   00004C   1E422C06     MOV.W   &0x62c, R14
   \   000050   CD4E....     MOV.B   R14, USB_Char_Rx(R13)
    308          if (++usb_rx_ring_wr >= (SMALL_RING_SIZE))
   \   000054   1F42....     MOV.W   &usb_rx_ring_wr, R15
   \   000058   1F53         ADD.W   #0x1, R15
   \   00005A   824F....     MOV.W   R15, &usb_rx_ring_wr
   \   00005E   3F901000     CMP.W   #0x10, R15
   \   000062   3428         JNC     ??USCI_A3_ISR_2
    309          {
    310            usb_rx_ring_wr = BEGINNING; // Circular buffer back to beginning
   \   000064   8243....     MOV.W   #0x0, &usb_rx_ring_wr
    311          }
    312          break;
   \   000068   313C         JMP     ??USCI_A3_ISR_2
    313          case 4: // Vector 4 – TXIFG
    314            
    315              switch(UCA3_index++)
   \                     ??USCI_A3_ISR_11:
   \   00006A   1F42....     MOV.W   &UCA3_index, R15
   \   00006E   0E4F         MOV.W   R15, R14
   \   000070   1E53         ADD.W   #0x1, R14
   \   000072   824E....     MOV.W   R14, &UCA3_index
   \   000076   0F83         SUB.W   #0x0, R15
   \   000078   1724         JEQ     ??USCI_A3_ISR_7
   \   00007A   1F83         SUB.W   #0x1, R15
   \   00007C   1524         JEQ     ??USCI_A3_ISR_7
   \   00007E   1F83         SUB.W   #0x1, R15
   \   000080   1324         JEQ     ??USCI_A3_ISR_7
   \   000082   1F83         SUB.W   #0x1, R15
   \   000084   1124         JEQ     ??USCI_A3_ISR_7
   \   000086   1F83         SUB.W   #0x1, R15
   \   000088   0F24         JEQ     ??USCI_A3_ISR_7
   \   00008A   1F83         SUB.W   #0x1, R15
   \   00008C   0D24         JEQ     ??USCI_A3_ISR_7
   \   00008E   1F83         SUB.W   #0x1, R15
   \   000090   0B24         JEQ     ??USCI_A3_ISR_7
   \   000092   1F83         SUB.W   #0x1, R15
   \   000094   0924         JEQ     ??USCI_A3_ISR_7
   \   000096   1F83         SUB.W   #0x1, R15
   \   000098   0724         JEQ     ??USCI_A3_ISR_7
   \   00009A   1F83         SUB.W   #0x1, R15
   \   00009C   0524         JEQ     ??USCI_A3_ISR_7
   \   00009E   1F83         SUB.W   #0x1, R15
   \   0000A0   0B24         JEQ     ??USCI_A3_ISR_8
   \   0000A2   1F83         SUB.W   #0x1, R15
   \   0000A4   0D24         JEQ     ??USCI_A3_ISR_9
   \   0000A6   103C         JMP     ??USCI_A3_ISR_3
    316              {
    317                case 0: //
    318                case 1: //
    319                case 2: //
    320                case 3: //
    321                case 4: //
    322                case 5: //
    323                case 6: //
    324                case 7: //
    325                case 8: //
    326                case 9: //
    327                UCA3TXBUF = test_command[UCA3_index - 1];
   \                     ??USCI_A3_ISR_7:
   \   0000A8   1F42....     MOV.W   &UCA3_index, R15
   \   0000AC   5F4F....     MOV.B   LWRD(test_command + 65535)(R15), R15
   \   0000B0   4F4F         MOV.B   R15, R15
   \   0000B2   824F2E06     MOV.W   R15, &0x62e
    328                break;
   \   0000B6   0A3C         JMP     ??USCI_A3_ISR_2
    329                case 10: //
    330                UCA3TXBUF = 0x0D;
   \                     ??USCI_A3_ISR_8:
   \   0000B8   B2400D002E06 MOV.W   #0xd, &0x62e
    331                break;
   \   0000BE   063C         JMP     ??USCI_A3_ISR_2
    332                case 11: // Vector 0 - no interrupt
    333                UCA3TXBUF = 0x0A;
   \                     ??USCI_A3_ISR_9:
   \   0000C0   B2400A002E06 MOV.W   #0xa, &0x62e
    334                break;
   \   0000C6   023C         JMP     ??USCI_A3_ISR_2
    335                default:
    336                UCA3IE &= ~UCTXIE; // Disable TX interrupt
   \                     ??USCI_A3_ISR_3:
   \   0000C8   A2C33A06     BIC.W   #0x2, &0x63a
    337                break;
    338              }     
    339            
    340          break;
    341          default: break;
    342          }
    343          }
   \                     ??USCI_A3_ISR_2:
   \   0000CC   2D17         POPM.W  #0x3, R15
   \   0000CE   0013         RETI
   \   0000D0                REQUIRE _A_UCA3RXBUF_L
   \   0000D0                REQUIRE _A_UCA3TXBUF_L
   \   0000D0                REQUIRE _A_UCA3IE_L
   \   0000D0                REQUIRE _A_UCA3IV_L

   \                                 In  segment INTVEC, offset 0x30, root
   \                     `??USCI_A3_ISR::??INTVEC 48`:
   \   000030   ....         DC16    USCI_A3_ISR

   \                                 In  segment INTVEC, offset 0x36, root
   \                     `??BUTTON_interrupt::??INTVEC 54`:
   \   000036   ....         DC16    BUTTON_interrupt

   \                                 In  segment INTVEC, offset 0x58, root
   \                     `??Timer0_A1_Interrupt::??INTVEC 88`:
   \   000058   ....         DC16    Timer0_A1_Interrupt

   \                                 In  segment INTVEC, offset 0x5a, root
   \                     `??Timer0_A0_ISR::??INTVEC 90`:
   \   00005A   ....         DC16    Timer0_A0_ISR

   \                                 In  segment INTVEC, offset 0x5c, root
   \                     `??ADC12_ISR::??INTVEC 92`:
   \   00005C   ....         DC16    ADC12_ISR

   \                                 In  segment INTVEC, offset 0x60, root
   \                     `??USCI_A0_ISR::??INTVEC 96`:
   \   000060   ....         DC16    USCI_A0_ISR
    344          //------------------------------------------------------------------------------

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   ADC12_ISR
      6   BUTTON_interrupt
      4   Init_Timer_A0
     12   Timer0_A0_ISR
       12   -> Display_Update
      6   Timer0_A1_Interrupt
     10   USCI_A0_ISR
     10   USCI_A3_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     108  ADC12_ISR
       2  ADC12_ISR::??INTVEC 92
       2  ADC_Left_Detector
       2  ADC_Right_Detector
       2  ADC_Thumb
     114  BUTTON_interrupt
       2  BUTTON_interrupt::??INTVEC 54
      62  Init_Timer_A0
      62  Timer0_A0_ISR
       2  Timer0_A0_ISR::??INTVEC 90
     110  Timer0_A1_Interrupt
       2  Timer0_A1_Interrupt::??INTVEC 88
     154  USCI_A0_ISR
       2  USCI_A0_ISR::??INTVEC 96
     208  USCI_A3_ISR
       2  USCI_A3_ISR::??INTVEC 48
       2  _A_ADC12IV_L
       2  _A_ADC12MEM0_L
       2  _A_ADC12MEM1_L
       2  _A_ADC12MEM2_L
       2  _A_PAOUT_L
       2  _A_PCIE_L
       2  _A_PCIFG_L
       2  _A_TA0CCR0_L
       2  _A_TA0CCR1_L
       2  _A_TA0CCTL0_L
       2  _A_TA0CCTL1_L
       2  _A_TA0CTL_L
       2  _A_TA0EX0_L
       2  _A_TA0IV_L
       2  _A_UCA0IE_L
       2  _A_UCA0IV_L
       2  _A_UCA0RXBUF_L
       2  _A_UCA0TXBUF_L
       2  _A_UCA3IE_L
       2  _A_UCA3IV_L
       2  _A_UCA3RXBUF_L
       2  _A_UCA3TXBUF_L
       2  countChar
       2  displaybutton1
       2  displaybutton2
       1  readFlag

 
  62 bytes in segment CODE
  44 bytes in segment DATA16_AN
  13 bytes in segment DATA16_Z
  12 bytes in segment INTVEC
 756 bytes in segment ISR_CODE
 
 818 bytes of CODE  memory
   0 bytes of CONST memory (+ 12 bytes shared)
  13 bytes of DATA  memory (+ 44 bytes shared)

Errors: none
Warnings: none
